//
// Created by Qing Xu on 2021/11/26.
//

#ifndef __joyeer_runtime_types_h__
#define __joyeer_runtime_types_h__

#include <cstdlib>
#include <string>
#include <vector>

struct Bytecodes;

typedef char            Byte;
typedef int64_t         Int;
typedef bool            Bool;
typedef uintptr_t       FuncPtr;
typedef uintptr_t       Any;
typedef intptr_t        Slot;
typedef const char*     FramePtr;

union Value {
    Int         intValue;
    Bool        boolValue;
    Slot        slotValue;
};

// Constants
constexpr int kValueSize = sizeof(Value);
constexpr int kByteSize = sizeof(Byte);
constexpr int kIntSize = sizeof(Int);
constexpr int kBoolSize = sizeof (Bool);

// Value Types
enum class ValueType : uint8_t {
    Void = 0x00,
    Int,
    Bool,
    Nil,
    Unspecified,
    Any,
    String,
    RESOLVED_PRIMARY_TYPE_COUNT [[maybe_unused]],
    Module,
    Class,
    Block,
    Func
};

enum class BuildIns : uint16_t {
    Func_Print = static_cast<size_t>(ValueType::RESOLVED_PRIMARY_TYPE_COUNT) - 1,

    Object_Array,
    Object_Array_Func_append,
    Object_Array_Func_size,
    Object_Array_Func_get,
    Object_Array_Func_set
};


enum AccessFlag : uint32_t {
    Public = 0x0001,
    Private = 0x0002,
    Protected = 0x0004,
    Static = 0x0008
};

std::string debugAccessFlag(AccessFlag flag);

// Type is generated by compiler, which represent a **Type**
struct Type {
    std::string name;
    ValueType kind;
    int32_t slot;

protected:
    Type(std::string  name, ValueType kind):
            name(std::move(name)),
            kind(kind),
            slot(-1) {
    }
};

// represent Nil kind
struct NilType : Type {
    NilType();
};

// represent Void kind
struct VoidType : Type {
    VoidType();
};

// represent Any kind
struct AnyType : Type {
    AnyType(): Type("Any", ValueType::Any) {}
};

// Represent types are not unspecified
struct UnspecifiedType: Type {
    UnspecifiedType(): Type("Unspecified", ValueType::Unspecified) {}
};

// Variable for Field/LocalVariable declarations
// will be used in ClassType/ModuleType/FuncType
struct Variable {

    // the debugger name's variable/field
    const std::string name;

    int parentSlot = -1; // Variable's parentTypeSlot Type, e.g. ClassType/ModuleType/FuncType
    int typeSlot = -1; // Variable's type
    int loc = -1;

    AccessFlag accessFlags = AccessFlag::Public;

    void markAsStatic() {
        accessFlags = static_cast<AccessFlag>( accessFlags | AccessFlag::Static);
    }

    // is a static variable, field only
    [[nodiscard]] bool isStatic() const {
        return (accessFlags & AccessFlag::Static) == AccessFlag::Static;
    }

    explicit Variable(std::string  name): name(std::move(name)) {}
};

// Represent Int kind
struct IntType : Type {
    IntType();
};

// Represent Bool kind
struct BoolType : Type {
    BoolType();
};

// Represent Statement Block Type
struct BlockType : Type {
    std::vector<Variable*> localVars; // local-variables

    BlockType();
};

enum FuncTypeKind : uint8_t {
    C_Func,
    VM_Func
};

// Represent Function kind (include class's function kind)
struct FuncType : Type {

    FuncTypeKind funcKind;
    BlockType* block;
    std::vector<Variable*> paramTypes;
    std::vector<Variable*> localVars;
    int returnTypeSlot = -1;
    Bytecodes* bytecodes = nullptr;

    explicit FuncType(const std::string& name);

    int getLocalVarCount() const ;
};

struct ClassType : BlockType {
    using Ptr = std::shared_ptr<ClassType>;

    intptr_t staticArea = -1;
    explicit ClassType(const std::string& name);
};

struct ModuleType : ClassType {
    using Ptr = std::shared_ptr<ModuleType>;

    // File initialize instructions
    Bytecodes* bytecodes  = nullptr;

    explicit ModuleType(const std::string& name);
};

#endif //__joyeer_runtime_types_h__
