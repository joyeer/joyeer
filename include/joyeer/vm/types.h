//
// Created by Qing Xu on 2021/11/4.
//

#ifndef __joyeer_vm_metadata_h__
#define __joyeer_vm_metadata_h__

struct IsolateVM;
struct Executor;
struct Object;
struct Bytecodes;
struct Arguments;

#include <vector>

#include "joyeer/common/types.h"
#include "joyeer/vm/heaps.h"

// Class's field description
struct Field {
    ValueType type;

    explicit Field(ValueType type): type(type) {}

    // get the size of the field
    [[nodiscard]] size_t getSize() const {
        return kIntSize;
    }

#undef DECLARE_TYPE
};

enum class MethodKind: intptr_t {
    VM_Method,
    C_Method
};

struct Method {
    Slot slot = -1;
    MethodKind kind;

    explicit Method(MethodKind kind): kind(kind) {}

    virtual Value operator () (Executor* executor, Arguments* args) const = 0;
};

// Method implemented in C
struct CMethod : Method {
    explicit CMethod(): Method(MethodKind::C_Method) {}
};

// Method generated by compiler and contains Bytecodes
struct VMethod : Method {
    explicit VMethod(Bytecodes* bytecodes, int paramCount, int localVarCount);
    ~VMethod();

    Value operator()(Executor* executor, Arguments* args) const override;
    int paramCount;
    int localVarCount;
    Bytecodes* bytecodes;
};

// Class description
struct Class {

    constexpr static int kObjectHeadOffset = 0;

    Slot slot = -1;         // memory slot slot
    intptr_t staticArea{};  // static member area

    std::vector<Field> instanceFields {};
    std::vector<Field> staticFields {};

    std::vector<FuncPtr> instanceMethods {};
    std::vector<FuncPtr> staticMethods {};

    virtual size_t getSize() const {
        size_t size = 0;
        for(const auto& field: instanceFields) {
            size += field.getSize();
        }
        return size;
    }

    [[nodiscard]] size_t getStaticSize() const {
        size_t size = 0;
        for(const auto& field: staticFields) {
            size += field.getSize();
        }
        return size;
    }

};

struct ModuleClass : public Class {
    Slot initializerSlot = -1; // slotId of the initializer method
};

// Array Object class
struct ArrayClass : public Class {
    constexpr static int kArrayCapacityOffset = kObjectHeadOffset + kIntSize;
    constexpr static int kArrayLengthOffset = kArrayCapacityOffset + kIntSize;
    constexpr static int kArrayDataOffset = kArrayLengthOffset + kIntSize;

    intptr_t allocate(IsolateVM* isolateVm, int capacity);

    void setCapacity(intptr_t object, Value capacity);
    Value getCapacity(intptr_t object);

    void setLength(intptr_t object, Value length);
    Value getLength(intptr_t object);

    void append(intptr_t object, Value value);

    void set(intptr_t object, Value index, Value value);
    Value get(intptr_t object, Value index);

private:
    // calculate array object size based on capacity
    // result size should be (power of 2 + kArrayDataOffset)
    static size_t calculateArrayCapacitySize(int size);
};


//
struct IntClass : public Class {
    constexpr static int kIntValueOffset = 0;
    explicit IntClass(): Class() {
        instanceFields.emplace_back(ValueType::Int);
    }
};



#endif //__joyeer_vm_metadata_h__
