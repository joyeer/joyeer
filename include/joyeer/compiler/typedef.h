//
// Created by Qing Xu on 2021/10/16.
//

#ifndef __joyeer_compiler_typedef_h__
#define __joyeer_compiler_typedef_h__

#include "joyeer/compiler/opcode.h"

#include <string>

enum class TypeKind : uint8_t {
    Void = 0x00,
    Nil,
    Boolean,
    Integer,
    Long,
    Any,

    FileModule,
    Class,
    Block,
    Function,
    Variable
};

enum AccessFlag : uint32_t {
    Public = 0x0001,
    Private = 0x0002,
    Protected = 0x0004,
    Static = 0x0008
};

std::string debugAccessFlag(AccessFlag flag);

// typedef is generated by compiler, which represent a **Type**
struct Type {
    using Ptr = std::shared_ptr<Type>;

    const std::string name;
    TypeKind kind;
    int32_t address;

protected:
    Type(std::string  name, TypeKind kind):
            name(std::move(name)),
            kind(kind),
            address(-1) {
    }
};

// represent Nil kind
struct NilType : Type {
    using Ptr = std::shared_ptr<NilType>;
    NilType();
};

// represent Void kind
struct VoidType : Type {
    using Ptr = std::shared_ptr<VoidType>;
    VoidType();
};

// represent Any kind
struct AnyType : Type {
    using Ptr = std::shared_ptr<AnyType>;
    AnyType(): Type("Any", TypeKind::Any) {}
};

// Variable for Field/LocalVariable declarations
// will be used in ClassDef/FileModuleDef/FuncDef
struct VariableType: Type {
    using Ptr = std::shared_ptr<VariableType>;

    int position = -1;
    int parent = -1;
    AccessFlag accessFlags = AccessFlag::Public;

    void markAsStatic() {
        accessFlags = static_cast<AccessFlag>( accessFlags | AccessFlag::Static);
    }

    // is a static variable, field only
    [[nodiscard]] bool isStatic() const {
        return (accessFlags & AccessFlag::Static) == AccessFlag::Static;
    }

    explicit VariableType(std::string  name):
            Type(name, TypeKind::Variable) {}
};

// Represent Int kind
struct IntType : Type {
    using Ptr = std::shared_ptr<IntType>;
    IntType();
};

// Represent Bool kind
struct BoolType : Type {
    using Ptr = std::shared_ptr<BoolType>;
    BoolType();
};

// Represent Statement Block Type
struct BlockType : Type {
    using Ptr = std::shared_ptr<BlockType>;

    int32_t base = -1; // re-located address for block variables
    std::vector<VariableType::Ptr> localVars; // local-variables

    BlockType();
};

enum FuncTypeKind : uint8_t {
    C_Func,
    VM_Func
};

// Represent Function kind (include class's function kind)
struct FuncType : Type {
    using Ptr = std::shared_ptr<FuncType>;

    FuncTypeKind funcKind;
    BlockType::Ptr block;
    std::vector<Type::Ptr> paramTypes;
    Type::Ptr returnType;
    std::vector<Instruction> instructions;

    explicit FuncType(const std::string& name);
};

struct ClassType : Type {
    using Ptr = std::shared_ptr<ClassType>;

    explicit ClassType(const std::string& name);

    static ClassType::Ptr create(const std::string& name) {
        return std::make_shared<ClassType>(name);
    }
};

struct ModuleType : ClassType {
    using Ptr = std::shared_ptr<ModuleType>;

    // include ClassDef/FuncDef
    BlockType::Ptr block;

    // File initialize instructions
    std::vector<Instruction> instructions;

    std::vector<VariableType::Ptr> getVariables() {
        return block->localVars;
    }

    explicit ModuleType(const std::string& name);
};

namespace BuildIn::Types {
    // call CompilerService to register the following Types
    [[maybe_unused]] static const VoidType::Ptr Void = std::make_shared<VoidType>();
    [[maybe_unused]] static const AnyType::Ptr Any = std::make_shared<AnyType>();
    [[maybe_unused]] static const NilType::Ptr Nil = std::make_shared<NilType>();
    [[maybe_unused]] static const IntType::Ptr Int = std::make_shared<IntType>();
    [[maybe_unused]] static const BoolType::Ptr Bool = std::make_shared<BoolType>();

    static const ClassType::Ptr String = std::make_shared<ClassType>("String");

    static const FuncType::Ptr print = std::make_shared<FuncType>("print(message:)");
};

#endif //__joyeer_compiler_typedef_h__
