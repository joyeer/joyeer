//
// Created by Qing Xu on 2021/10/16.
//

#ifndef __joyeer_compiler_typedef_h__
#define __joyeer_compiler_typedef_h__

#include "joyeer/runtime/types.h"
#include "joyeer/compiler/opcode.h"

#include <string>
#include <utility>

enum AccessFlag : uint32_t {
    Public = 0x0001,
    Private = 0x0002,
    Protected = 0x0004,
    Static = 0x0008
};

std::string debugAccessFlag(AccessFlag flag);

// Type is generated by compiler, which represent a **Type**
struct Type {
    using Ptr = std::shared_ptr<Type>;

    const std::string name;
    ValueType kind;
    int32_t slot;

protected:
    Type(std::string  name, ValueType kind):
            name(std::move(name)),
            kind(kind),
            slot(-1) {
    }
};

// represent Nil kind
struct NilType : Type {
    using Ptr = std::shared_ptr<NilType>;
    NilType();
};

// represent Void kind
struct VoidType : Type {
    using Ptr = std::shared_ptr<VoidType>;
    VoidType();
};

// represent Any kind
struct AnyType : Type {
    using Ptr = std::shared_ptr<AnyType>;
    AnyType(): Type("Any", ValueType::Any) {}
};

// Represent types are not unspecified
struct UnspecifiedType: Type {
    using Ptr = std::shared_ptr<UnspecifiedType>;
    UnspecifiedType(): Type("Unspecified", ValueType::Unspecified) {}
};

// Variable for Field/LocalVariable declarations
// will be used in ClassType/ModuleType/FuncType
struct Variable {
    using Ptr = std::shared_ptr<Variable>;

    // the debugger name's variable/field
    const std::string name;

    int parentSlot = -1; // Variable's parentTypeSlot Type, e.g. ClassType/ModuleType/FuncType
    int typeSlot = -1; // Variable's type
    int location = -1;

    AccessFlag accessFlags = AccessFlag::Public;

    void markAsStatic() {
        accessFlags = static_cast<AccessFlag>( accessFlags | AccessFlag::Static);
    }

    // is a static variable, field only
    [[nodiscard]] bool isStatic() const {
        return (accessFlags & AccessFlag::Static) == AccessFlag::Static;
    }

    explicit Variable(std::string  name): name(std::move(name)) {}
};

// Represent Int kind
struct IntType : Type {
    using Ptr = std::shared_ptr<IntType>;
    IntType();
};

// Represent Bool kind
struct BoolType : Type {
    using Ptr = std::shared_ptr<BoolType>;
    BoolType();
};

// Represent Statement Block Type
struct BlockType : Type {
    using Ptr = std::shared_ptr<BlockType>;

    std::vector<Variable::Ptr> localVars; // local-variables

    BlockType();
};

enum FuncTypeKind : uint8_t {
    C_Func,
    VM_Func
};

// Represent Function kind (include class's function kind)
struct FuncType : Type {
    using Ptr = std::shared_ptr<FuncType>;

    FuncTypeKind funcKind;
    BlockType::Ptr block;
    std::vector<Variable::Ptr> paramTypes;
    std::vector<Variable::Ptr> localVars;
    int returnTypeSlot = -1;
    std::vector<Instruction> instructions {};

    explicit FuncType(const std::string& name);

    int getLocalVarCount() const ;
};

struct ClassType : Type {
    using Ptr = std::shared_ptr<ClassType>;

    explicit ClassType(const std::string& name);

};

struct ModuleType : BlockType {
    using Ptr = std::shared_ptr<ModuleType>;

    // File initialize instructions
    std::vector<Instruction> instructions;

    [[nodiscard]] std::vector<Variable::Ptr> getVariables() const {
        return localVars;
    }

    explicit ModuleType(const std::string& name);
};

#endif //__joyeer_compiler_typedef_h__
